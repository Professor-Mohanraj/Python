**UNIT I**

**COMPUTATIONAL THINKING AND PROBLEM SOLVING**

*Fundamentals of Computing – Identification of Computational Problems -Algorithms, building blocks of algorithms (statements, state, control flow, functions), notation (pseudo code, flow chart, programming language), algorithmic problem solving, simple strategies for developing algorithms (iteration, recursion).*

***Illustrative problems:*** *find minimum in a list, insert a card in a list of sorted cards, Guess an integer number in a range, Towers of Hanoi.*

**1.1 	FUNDAMENTALS OF COMPUTING**

**1.1.1 Computer:**

A Computer is an electronic machine that can be programmed to accept data (***input***), and process it into useful information (***output***).  Data is put into secondary storage (***storage***) for safekeeping or later use.  

The ***processing*** of input into output is **directed by the software**, but ***performed by the hardware***.

`                           `**![](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.001.png)**

***Figure 1: Basics of Computer***

**1.1.2 History of Computers:**

**Tally Sticks:**

A tally stick was an ancient memory aid device to record and document numbers, quantities, or even messages.


**Abacus:**

An abacus is a mechanical device used to aid an individual in performing mathematical calculations. The abacus was invented in Babylonia in 2400 B.C. The abacus in the form we are most familiar with was first used in China in around 500 B.C. It used to perform basic arithmetic operations.

**Napier’s Bones:**

Invented by John Napier in 1614. Allowed the operator to multiply, divide and calculate square and cube roots by moving the rods around and placing them in specially constructed boards.

**Slide Rule:**

Invented by William Oughtred in 1622. It is based on Napier's ideas about logarithms. It is used primarily for Multiplication, division, roots, logarithms, Trigonometry Not normally used for addition or subtraction.

**Pascaline:**

Invented by Blaise Pascal in 1642. It was its limitation to addition and subtraction. It is too expensive.

**Stepped Reckoner:**

Invented by Gottfried Wilhelm Leibniz in 1672. The machine that can add, subtract, multiply and divide automatically.

**Arithmometer:**

A mechanical calculator invented by Thomas de Colmar in 1820.  The first reliable, useful and commercially successful calculating machine. The machine could perform the four basic mathematic functions.

**Difference Engine and Analytical Engine:**

It an automatic, mechanical calculator designed to tabulate polynomial functions. It was invented by Charles Babbage in 1822 and 1834. It is the first mechanical computer.

**First Computer Programmer:**

In 1840, Augusta Ada Byron suggests to Babbage that he use the binary system. She writes programs for the Analytical Engine.

**Scheutzian Calculation Engine:**

Invented by Per Georg Scheutz in1843. It is based on Charles Babbage's difference engine. ***The first printing calculator***.

**Tabulating Machine:**

` `It was invented by Herman Hollerith in 1890.  It is to assist in summarizing information and accounting.

**Havard Mark 1:**

It is also known as IBM ***Automatic Sequence Controlled Calculator*** (ASCC). It is invented by Howard H. Aiken in 1943.The first electro-mechanical computer.

**Z1:**

***The first programmable computer***, created by Konrad Zuse in Germany from 1936 to 1938.

**Atanasoff-Berry Computer (ABC):**

It was the ***first electronic digital computing device***. It was invented by Professor John Atanasoff and graduate student Clifford Berry at Iowa State University between 1939 and 1942.

**ENIAC:**

ENIAC stands for ***Electronic Numerical Integrator and Computer***. It was the first electronic general purpose computer. Completed in 1946. Developed by John Presper Eckert and John W. Mauchl.

**UNIVAC 1**

The UNIVAC I (UNIVersal Automatic Computer 1) was ***the first commercial computer***.  Designed by J. Presper Eckert and John Mauchly.

**EDVAC:**

EDVAC stands for Electronic Discrete Variable Automatic Computer. ***The First Stored Program Computer***. It was designed by Von Neumann in 1952. It has a memory to hold both a stored program as well as data.

**The First Portable Computer:**

Osborne 1 – ***the first portable computer***. Released in 1981 by the Osborne Computer Corporation.

**The First Computer Company:**

The first computer company was ***the Electronic Controls Company***. Founded in 1949 by J. Presper Eckert and John Mauchly.


**1.1.3 Generations of computer:**

The computer has evolved from a large-sized simple calculating machine to a smaller but much more powerful machine. The evolution of computer to the current state is defined in terms of the generations of computer. Each generation of computer is designed based on a new technological development, resulting in better, cheaper and smaller computers that are more powerful, faster and efficient than their predecessors.

Currently, there are five generations of computer.

**• First generation – 1940 - 1956**

**• Second generation – 1956 - 1963**

**• Third generation – 1964 - 1971**

**• Fourth generation – 1971 - today**

**• Fifth generation – Today to future**

**First Generations computer (1940-56):**

The first Generation computers used **vacuum tubes** for circuitry and **magnetic drums** for memory. They were often enormous and taking up entire room. First generation computers relied on machine language. They were very expensive to operate and in addition to using a great deal of electricity, generated a lot of heat, which was often the cause of malfunctions. The **UNIVAC** and **ENIAC** computers are examples of first-generation computing devices.

**Second Generations computer (1956-63):**

**Transistors** replaced vacuum tubes in the second generation of computers. One transistor replaced the equivalent of **40 vacuum tubes**. Second-generation computers moved from cryptic binary machine language to symbolic. High-level programming languages were also being developed at this time, such as early versions of COBOL and FORTRAN. These were also the first computers that stored their instructions in their memory. The **IBM 1620** and **UNIVAC 1108** are examples of Second-generation computing devices.

**Third Generations computer (1964-71):**

The development of the **Integrated Circuit** was the hallmark of the third generation of computers. Transistors were miniaturized and placed on silicon chips, called **semiconductors**. Instead of punched cards and printouts, users interacted with third generation computers through keyboards and monitors and interfaced with an operating system. Allowed the device to run many different applications at one time. **IBM-360 series** and **Honeywell-6000** series computers are example for third generation computers.


**Fourth Generations computer (1971-present):**

Computers of fourth generation used ***Very Large Scale Integrated (VLSI) circuits***. VLSI circuits having about 5000 transistors and other circuit elements with their associated circuits on a single chip made it possible to have microcomputers of fourth generation. Fourth generation computers became more powerful, compact, reliable, and affordable. All the high-level languages like C, C++, DBASE etc., were used in this generation. **PDP 11, CRAY-1(Super Computer), CRAY-X-MP(Super Computer)** are example for fourth generation computers.

**Fifth Generations computer (Present -Next):**

In the fifth generation, VLSI technology became ***ULSI (Ultra Large Scale Integration)*** technology, resulting in the production of microprocessor chips having ten million electronic components. This generation is based on parallel processing hardware and AI (Artificial Intelligence) software.AI try to simulate the human way of thinking and reasoning. All the high-level languages like C and C++, Java, .Net etc., are used in this generation.

**1.1.4 Types of computers:**

- Computers for Individual Use:
  - Desktop computers
  - Workstations
  - Notebook computers
  - Tablet computers
  - Handheld computers, Palm computers
  - Smart phones
- Computers for Organization:
  - Network servers
  - Mainframes
  - Mini computers
  - Super computers


**1.1.5 CHARACTERISTICS OF COMPUTERS:**

\1. **Speed**: Speed is the most important characteristics of computer .Computer having more speed to perform jobs instantaneously.

\2. **Accuracy:** The computers are perfect, accurate and precise. Accuracy signifies the reliability of the hardware components of computers.

\3. **Automatic:** A computer works automatically, once programs are stored and data are given to it, constant supervision is not required.

\4. **Endurance:** A computer works continuously and will not get tired and will not suffer from lack of concentration.

\5. **Versatility**: A computer can be put to work in various fields.

\6. **Reduction of cost**: Though initial investment may be high, computer substantially reduces the cost of transaction.

**1.1.6 Parts of Computers:**

- Hardware - Mechanical devices in the computer
- Software - Tell the computer what to do ,also called a program
- Data - Pieces of information , Computers organize and present data
- User - People operating the computer , Most important part, Tell the computer what to do


![parts](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.002.png)

***Figure 2 various parts of computer***




**1.1.7 What is computing?**

- Computing is any goal-oriented activity requiring, benefiting from or creating computers.
- Computing includes designing, developing and building hardware and software systems; processing, structuring and managing various kinds of information; doing scientific research on and with computers; making computer systems behave intelligently.
- Subfields of computing includes :
  - Computer Engineering, Computer Science
  - Software Engineering
  - Information Systems, Information Technology

**1.2 IDENTIFICATION OF COMPUTATIONAL PROBLEMS:**

**Problem:**

- Problem is a thing that requires logical thought and /or mathematics to solve.

**Problem Solving:**

- Problem solving is the systematic approach to define the problem and creating number of solutions. The problem solving process starts with the problem specifications and ends with a correct program.

**Problem Solving with Computers:**

Computers are built to solve problems with algorithmic solutions, which are often difficult or very time consuming when input is large. Solving a complicated calculus problem or alphabetizing 10,000 names is an easy task for the computer. So the basis for solving any problem through computers is by developing an algorithm. Field of computers that deals with heuristic types of problems are called Artificial Intelligence (AI) Artificial intelligence enables a computer to do things like human by building its own knowledge bank. As a result, the computer’s problem-solving abilities are similar to those of a human being.  Artificial intelligence is an expanding computer field, especially with the increased use of Robotics.

**Computational Problems:**

Computation is the process of evolution from one state to another in accordance with some rules.

A computational problem is a problem that a computer might be able to solve or a question that a computer may be able to answer.

![](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.003.png)

***Figure 3:* *Types of computational problems.***

**Computational thinking:**

*Computational thinking* is an approach to problem-solving that involves using a set of practices and principles from computer science to formulate a solution that’s executable by a computer.

‘Computational thinking is the thought processes involved in formulating a problem and expressing its solution(s) in such a way that a computer—human or machine—can effectively carry out.’

**Some examples of Computational Thinking:**

**Predicting climate change:**

Predicting global climate change is only possible because of advanced computer models. According to the UK Met Office, ‘The only way to predict the day-to-day weather and changes to the climate over longer timescales is to use computer models.’

**Assisting police, lawyers and judges:**

Computational Thinking has a long tradition in influencing the law, especially in the dream of providing a set of logical rules that can automate the process of reaching a verdict, its desire to minimize human discretion and maximize predictability of outcome. Legal reasoning systems have been making inroads where they merely try to assist those making legal decisions.




**1.3 	ALGORITHMS**

In computing, we focus on the type of problems categorically known as **algorithmic problems**, where their solutions are expressible in the form of algorithms. The term ‘***algorithm***’ was derived from the name of Mohammed al-Khwarizmi, a Persian mathematician in the ninth century (Al-Khwarizmi → Algorism (in Latin) → Algorithm). The typical meaning of an algorithm *is a formally defined procedure for performing some calculation*. If a procedure is formally defined, then it must be implemented using some formal language, and such languages are known as programming languages. 

The algorithm gives the logic of the program, that is, a step-by-step description of how to arrive at a solution. In general terms, ***an algorithm provides a blueprint to writing a program to solve a particular problem. It is considered to be an effective procedure for solving a problem in a finite number of steps.*** That is, a well defined algorithm always provides an answer, and is guaranteed to terminate. Algorithms are mainly used to achieve software reuse.

![](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.004.png)

***Figure 4: Algorithm***

***Real Life Example*** ***Procedure to cook Bread Toast*** 

*Step 1 : Grab a loaf of bread* 

*Step 2 : Get a pan and place it on the stove let it heat* 

*Step 3 : Pour some oil on the pan and wait for oil to be heated* 

*Step 4 : Put a slice on the pan and roast until it become brown in shade* 

*Step 5 : Turn the slice and roast until it become brown in shade* 

*Step 6 : Get the toasted bread from the pan and serve it on a plate with anything or nothing.*

*The above procedure that explains “how to make a bread toast” and what are all the requirements before we start the procedures. We can code this procedure or algorithm in any programming language of your choice and simulate as results on the computer display. Else we can feed this procedure to the robot with proper instructions and we make the robot to do the bread toast for us.*

***Example 1 :*** **Algorithm for adding two numbers:** 

*Step 1 : Get the 2 numbers from the user as input.* 

*Step 2 : Perform addition of those 2 numbers.* 

*Step 3 : Store the answer for display.* 

*Step 4 : Display the stored value to the user.*


**1.3.1	Why we need an Algorithm?**

` `Three reasons for using algorithms are efficiency, abstraction and reusability.

1) ***Efficiency***: Certain types of problems, like sorting, occur often in computing. Efficient algorithms must be used to solve such problems considering the time and cost factor involved in each algorithm.
1) ***Abstraction***: Algorithms provide a level of abstraction in solving problems because many seemingly complicated problems can be distilled into simpler ones for which well known algorithms exist. Once we see a more complicated problem in a simpler light, we can think of the simpler problem as just an abstraction of the more complicated one. For example, imagine trying to find the shortest way to route a packet between two gateways in an internet. Once we realize that this problem is just a variation of the more general shortest path problem, we can solve it using the generalized approach.
1) ***Reusability***: Algorithms are often reusable in many different situations. Since many well-known algorithms are the generalizations of more complicated ones, and since many complicated problems can be distilled into simpler ones, an efficient means of solving certain simpler problems potentially lets us solve many complicated problems.

**1.3.2 	Defining algorithms**

The definition of an algorithm is complex and involves several properties. 

**Those properties are:**

- **Collection of individual steps**
- **Definiteness**
- **Sequential**

**1) Collection of individual steps:**

- An algorithm is a collection of individual steps. 
- A recipe fits this analogy quite simply, filled as it is with steps like: **‘pre-heat the oven to 180 degrees Celsius’ or ‘add two tablespoons of sugar to the bowl’.**

**2) Definiteness:**

- **Definiteness,** meaning that every step must be precisely defined. 
- Each step in an algorithm can have one and only one meaning, otherwise it is ambiguous.
- Similarly, chefs have come to the same conclusion, which is why they produce recipes using precise measurements instead of writing things like ‘**some sugar**’ or ‘**cook it for a while**’.

**3) Sequential:**

- Algorithms are also **sequential**. 
- **The steps that make up the process must be carried out in the order specified.** Failing to do this means that the result of executing the algorithm is likely incorrect.
- Think back to the analogy. ***Dicing an onion*** and ***frying an onion*** are different steps. Dicing an onion before you fry it has a different outcome than the reverse.  Similarly, multiplying a number by 2 then adding 5 to it yields a different result from adding 5 first then doubling it.  Like a recipe, you must respect the sequence when running through an algorithm for it to have any meaningful result.

**1.3.3	Characteristics of Algorithm**

(1) **Precision:** The instructions should be written in a precise manner.

(2) **Uniqueness:** The outputs of each step should be unambiguous, i.e., they should be unique and only depend on the input and the output of the preceding steps.

(3) **Finiteness:** Not even a single instruction must be repeated infinitely.

(4)**Effectiveness:** The algorithm should be designed in such a way that it should be the most effective among many different ways to solve a problem.

(5) **Input:** The algorithm must receive an input.

(6) **Output:** After the algorithm gets terminated, the desired result must be obtained.

(7) **Generality:** The algorithm can be applied to various set of inputs

**1.3.4 Method for Developing an Algorithm**

(1) **Define the problem**: State the problem to be solved in clear and concise manner. 

(2) **List the inputs and outputs** 

(3) **Describe the steps needed to convert input to output** 

(4) **Test the algorithm**: Choose input data and verify that the algorithm works.

**1.4	BUILDING BLOCKS OF ALGORITHM (Instructions, State, Control Flow, Functions)**

**Building Blocks of Algorithms are,** Computer is not smart as we humans. It requires a much more than single instruction to do any task. We can express our needs to computer using the algorithms. An algorithm includes basic building blocks that are used to express any kind of the task to the computer. Algorithms can be constructed from basic building blocks namely, ***sequence, selection and iteration***.

***1. Instructions/ Statements*** 

***2. State*** 

***3. Control Flow*** 

***4. Functions***

**1.4.1 Instructions/ Statements**

In computer programming, a statement is the smallest standalone element of an imperative programming language that expresses some action to be carried out. It is an instruction written in a high-level language that commands the computer to perform a specified action.

There are two types of statement, ● Simple Statement ● Compound Statement

***Simple Statements*** - It is used to represent single action need to be done.

● **assertion**: assert(ptr != NULL);

Comparison

● **assignment**: A:= A + 5

Assigning a value 5 to A

● **goto**: goto next;

Sent the control to different block of same program

● **return**: return 5;

Return a value 5 after the execution of function

● **call**: clearScreen()

Calling the Function (clearScreen) which performs clearing previous outputs from the computer screen


***Compound Statement -*** It is a set of statements, that used to perform a sequence of operations repeatedly or condition based executions.

● ***block***: Set of statements

begin 

integer NUMBER; 

WRITE('Number? '); 

READLN(NUMBER); 

A:= A\*NUMBER 

end

● ***do-loop***: 

do { 

computation(&i); 

} while (i< 10);

Looping a set of statements repeatedly until some condition is satisfied. We can’t predict when the condition becomes satisfiable. At least it will do the loop sequence once.

● ***for-loop***: 

for A:=1 to 10 do 

WRITELN(A) 

end

Looping a set of statements repeatedly until some condition is satisfied. We can run the loop for certain iterations. Prediction of loop termination is possible.

● ***if-statement***: 	

if A > 3 then 

WRITELN(A) 

else 

WRITELN("NOT YET"); 

end

Normally it contains two sets of statements. State or value is compared with a conditions if it is satisfied the “if” block will be executed otherwise else part will be executed.

● ***switch-statement***: 

switch (c) { 

case 'a': alert(); break; 

case 'q': quit(); break; 

}

It contains more than two blocks of statement each one has the conditions. When the program reaches a state with a value, first hit of matching conditions block will be executed. If nothing matches then default block of statements will be executed

● ***while-loop***: 

while NOT EOF DO 

begin 

READLN 

end

Looping a set of statements repeatedly until some condition is satisfied. We can’t predict when the condition becomes satisfiable. This is loop is entry controlled. Control will enter into the loop only if condition is satisfiable.

**1.4.2 State:**

State: the current configuration of all information kept track of by a program at any one instant in time. 

As a computer progresses through an algorithm, just as you progress through a recipe, the state of things can change. 

Clearly sequencing the steps of an algorithm ensures that state always changes in the same way whenever the algorithm is executed.

In computer science, a program is described as stateful if it is designed to remember preceding events or user interactions; the remembered information is called the state of the system.

If a program gets sufficient data processed then it moves to another state. A successful execution of program include the reaching the final state of the program.

At each instant in time, the environment in which the algorithm is being run exists in some particular state. But by the time the next step is executed, something might have changed. The environment really exists as a series of snapshots, one for each step of the algorithm. The recipe analogy spells this out. At the start you might have butter, flour, milk, eggs and sugar. After each step, you take a photograph of the kitchen. The photos will show that, bit by bit, the state of the ingredients changes. Flour goes into a bowl; then the eggs join it; then the butter goes into the pan; and so on. There is no global view of the ingredients; just a series of snapshots.

**1.4.3 Control Flow**

In computer science, control flow (or flow of control) is **the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated.**

*Control Flow Statement* **-** Within an imperative programming language, a control flow statement is a statement which execution results in a choice being made as to which of two or more paths to follow.

**Control Flow Statement Categories:** 

● Continuation at a different statement (*unconditional branch or jump*) 

● Executing a set of statements only if some condition is met (choice - i.e., *conditional branch*)

● Executing a set of statements zero or more times, until some condition is met (i.e., loop - the same as conditional branch)

● Executing a set of distant statements, after which the flow of control usually returns (subroutines, co-routines, and continuations) 

● Stopping the program, preventing any further execution (unconditional halt)

**Primitive Control Statements:**

● ***Labels*** A label is an explicit name or number assigned to a fixed position within the source code, and which may be referenced by control flow statements appearing elsewhere in the source code. A label marks a position within source code, and has no other effect. 

Eg: **LET** X = 3 **PRINT** X

● ***Goto***

The goto statement (a combination of the English words go and to, and pronounced accordingly) is the most basic form of unconditional transfer of control. Eg: **goto** label

● ***Subroutines***

A piece of code was written once and then used many times from various other places in a program. The terminology for subroutines varies; they may alternatively be known as routines, procedures, functions (especially if they return results) or methods (especially if they belong to classes or type classes).

● ***Sequence***

In structured programming, the ordered sequencing of successive commands is considered one of the basic control structures, which is used as a building block for programs alongside iteration, recursion and choice.

● ***Other Control Flow Statements***

○ ***Choice***

- If-then-(else) statements
- Case and switch statements

○ ***Loops***

- Count-controlled loops
- Condition-controlled loops
- Collection-controlled loops

**1.4.4 Functions**

**Module** - A small component of a computer program that may contain several routines. 

**Parameter** - In computer programming, a parameter is a value that is passed into a function or procedure. 

**Procedure** - A section of computer code that performs a specific task.

Functions "Encapsulate" a task (they combine many instructions into a single line of code). Most programming languages provide many built in functions that would otherwise require many steps to accomplish, for example computing the square root of a number. In general, we don't care how a function does what it does; only that it "does it"!

When a function is "called" the program "leaves" the current section of code and begins to execute the first line inside the function. Thus the function "flow of control" is:

1. The program comes to a line of code containing a "function call".
1. The program enters the function (starts at the first line in the function code).
1. All instructions inside of the function are executed from top to bottom.
1. The program leaves the function and goes back to where it started from.
1. Any data computed and RETURNED by the function is used in place of the function in the original line of code.

***Why do we Write Functions?***

1. They allow us to conceive of our program as a bunch of sub-steps. (Each sub-step can be its own function. When any program seems too hard, just break the overall program into sub-steps!)
1. They allow us to reuse code instead of rewriting it.
1. Functions allow us to keep our variable namespace clean (local variables only "live" as long as the function does). In other words, function\_1 can use a variable called i, and function\_2 can also use a variable called i and there is no confusion. Each variable i only exists when the computer is executing the given function.
1. Functions allow us to test small parts of our program in isolation from the rest. This is especially true in interpreted languages, such as Matlab, but can be useful in C, Java, ActionScript, etc.

***Steps to Writing a Function:***

1. Understand the purpose of the function.
1. Define the data that comes into the function from the caller (in the form of parameters)!
1. Define what data variables are needed inside the function to accomplish its goal.
1. Decide on the set of steps that the program will use to accomplish this goal. (The Algorithm)

***Types of Functions:***

● ***Parameterized Functions***

- These functions that receives input while calling. It may or may not return any value to the caller.

● ***Non-Parameterized Function***

- These functions do not receive any input while calling. It may or may not return any value to the caller.



**1.5 	NOTATION OF ALGORITHM**

Algorithms are basically a set of instructions that, if correct and if followed carefully, produce some desired result. Since they are sets of instructions, they are generally presented in such a way that that the step-by-step nature of how they should be followed is readily apparent. The two most common representations are pseudo code and flowcharts.

Algorithms can be thought of as the recipe for taking the general solution for a class of problem and applying it to a specific instance of a problem covered by that class. For instance, the class of problem might be to find the surface area of a sphere given its radius. Through some problem solving means - perhaps by performing the fundamental calculus computation or perhaps simply by looking up the equation in a math book, we determine that the general solution to the problem is that the area is four times, *pi* times the square of the radius. 

We can then use this general solution and create an algorithm that permits use to compute the surface area of a specific sphere:

TASK:	 Compute the surface area of a sphere
GET: 	radius
SET: 	area = 4 \* pi \* *radius \* radius*




**1.5.1	PSEUDO CODE**

Pseudocode is an artificial and informal language that helps programmers to develop algorithms. Pseudo code is a "text-based" detail (algorithmic) design tool.

The rules of Pseudocode are reasonably straightforward. All statements showing "dependency" are to be indented. These include while, do, for, if, switch. Examples below will illustrate this notion.

**Rules for Pseudocode Writing**

1. For looping and selection, The keywords that are to be used include Do While...EndDo; Do Until...EndDo; Case...EndCase; If...Endif; Call ... with (parameters); Call; Return ....; Return; When; Always use scope terminators for loops and iteration.
1. As verbs, use the words Generate, Compute, Process, etc. Words such as set, reset, increment, compute, calculate, add, sum, multiply, ... print, display, input, output, edit, test , etc. with careful indentation tend to foster desirable pseudocode.
1. Do not include data declarations in your pseudocode.



**Example: *For finding the given number is odd or even***

INPUT number
COMPUTE modulo for that number
IF modulo value equals to zero
PRINT “The number is Even”
ELSE
PRINT “The number is Odd”
END

**1. Documentation Keywords**

Documentation keywords describe what needs to be done or provides information about why something is being done. You will quickly discover that, if you have done a decent job of writing your pseudocode that these lines make very useful comment lines in your final code.

● TASK:

A TASK statement is something that the program must perform but that is described at a level more abstract than what can be coded directly. One way to think of it is that you break a problem down into a set of TASKs. Each TASK can, in turn, be broken down into more narrowly defined TASKs. At some point, the TASK can be described in terms of steps that can be directly implemented. From one perspective, anytime a TASK: keyword is used, it means that there should (or at least could) be a subordinate level of the hierarchy which is the pseudo code for that TASK. In practice, that pseudo code need not be present if the TASK is sufficiently narrow that the person implementing it can go directly from the TASK description to the actual code without the benefit of the detailed steps.

● REM:

A REM statement is merely a remark or comment. They are useful if the TASK statement proves to be insufficient to convey all the desired information or if the reason that something is done or why it works is not obvious..

**2. Action Keywords**

Action keywords are the lines that actually do the work. There are three basic actions that can be carried out: changing the value stored at some location in memory, getting input from some device, or generating output to some device. We will use the SET, GET, and PUT keywords for these actions respectively.

● SET:

This is an "action" keyword that denotes performing some operation that changes a value in memory. The most common example would be the evaluation of some equation.

● PUT:

This is an "action" keyword that denotes an output operation, generally to the screen. If the destination is anything other than the screen, such as a file or the serial port, then that should be explicitly stated.

● GET:

This is an "action" keyword that denotes in input operation, generally from the keyboard. It is generally understood that there is an implied SET action involved where the value brought in gets stored in some memory location. If the source is anything other than the keyboard, such as a file or the serial port, then that should be explicitly stated.

**3. Flow Control Keywords**

While the action keywords perform the actual work, they are insufficient in and of themselves to write all but the most trivial programs. Of the three structured programming constructs, the action keywords are only sufficient to implement the first of them, namely a sequence of instructions. A program's true power comes from the other two - selection and repetition - because they give it the ability to select whether a particular action will actually be carried out based on the information made available to it at the time that it is executed. This ability is the result of controlling the flow of the program which is the purpose of the flow control keywords.

Because flow control is a more complex task that merely executing a single statement, all but the simplest flow control keywords are used in groups and there are some options in how to use them depending on the specific situation.

Selection - Case 1

● SEL: (test condition)

- TRUE : Statement(s) to be executed if test condition is TRUE
- FALSE : Statement(s) to be executed if test condition is FALSE

Selection - Case 2

● IF: (test condition)

- Statement(s) to be executed if test condition is TRUE-

● ELSE:

- Statement(s) to be executed if test condition is FALSE

The advantage of Case 1 is that it clearly identifies the block as a selection construct, but it is a bit more involved than is usually necessary. The format of Case 2 is very close to the format of the actual C code that would result and is therefore a bit more straightforward to convert in the coding process, but not enough so as to be a significant factor.

In a legal outline, the ELSE: statement in Case 2 would be numbered one more than the IF: statement - in other words, if the IF: statement was numbered 3.4.2.6) then the ELSE: statement would be numbered 3.4.2.7). This can be useful or confusing depending upon how you think of it. If you think of the test condition controlling a single selection construct, then it would be nice if the controlling expression was one level in the outline and everything it controls was at a lower level. So this could be a bit confusing. However, this format actually emphasizes the fact that, in C, an "else" statement truly is a separate statement and that it must immediately follow an "if" statement that is at the same level of control. Neither convention is significantly better than the other - and you should quickly get comfortable with whichever you choose to use.

Repetition - Case 1

● LOOP:

- WHILE: (test condition)
- Statement(s) to be executed if test condition is TRUE

Repetition - Case 2 

● LOOP:

- Statement(s) to be executed if test condition is TRUE
- WHILE: (test condition)

These two cases map directly into the while() and do/while() looping constructs of the C language. In Case 1, the test condition is evaluated prior to making the first pass through the statements controlled by it and, as a result, the possibility exists that those statements won't be executed even once. The only difference in Case 2 is that the statements controlled by the test condition are executed one time and the test is evaluated after that first pass. If the test condition is TRUE then another pass is made - and the test condition evaluated at the end of that and each succeeding pass until the test finally fails.

While the two cases above are more than adequate to represent any looping logic - in fact, either one of them by itself is sufficient, just more cumbersome in some cases - the logic is sometime clearer to the reader if it is expressed in terms of repeating the loop until some  condition is met - meaning that the loop is terminated as soon as the test condition becomes TRUE.

Repetition - Case 3

● LOOP:

- UNTIL: (test condition)
- Statement(s) to be executed if test condition is FALSE

Repetition - Case 4

● LOOP:

- Statement(s) to be executed if test condition is FALSE
- UNTIL: (test condition)

Although C does not support a "loop until" construct (some languages do) converting Case 3 to an equivalent form of Case 1 is trivial - you simply invert the test condition. Similarly, Case 4 can be converted to Case 2 by the same mechanism.

Just as the selection construct can be streamlined, so too can a couple of the repetition constructs.

Repetition - Case 5 (streamlined version of Case 1)

● WHILE: (test condition)

- Statement(s) to be executed if test condition is TRUE

Repetition - Case 6 (streamlined version of Case 3)

● >UNTIL: (test condition)

- Statement(s) to be executed if test condition is FALSE

Streamlining the other two is more difficult because, since the test comes at the end of the statement within the loop, it is very useful to mark the beginning of those statements in such a way that the fact that it is a loop is readily apparent to the reader. The LOOP: statement does that about as well as any other option would.

As you code loops, you will discover that it is frequently the case that there are steps that are logically associated with the loop but which must reside outside of the loop code. The most common by far is the need to initialize certain variables, especially counters, prior to entering the loop. Much less frequently, it is necessary to perform some cleanup tasks immediately after the loop is exited. A pseudocode construct that gathers all of these together so that their association is obvious is the following:

Repetition - Case 7 

REP:

- PRE:
  - Statement(s) to be executed prior to entering loop
- WHILE: (test condition)
  - Statement(s) to be executed if test condition is TRUE
- LOOP:
- POST:
  - Statement(s) to be executed prior after the loop is finished

The above can be easily altered so as to cover all four of the first four cases. As shown, it implements Case 1. By switching the WHILE: and LOOP: statements it implements Case 2. Similarly, Case 3 is obtained simply by changing the WHILE: to UNTIL: and swapping the UNTIL: with the LOOP: then generated Case 4.




**Examples:**

1) ***Pseudo Code for Sum of two numbers:***

TASK : Sum of two numbers
READ num1
READ num2
Compute SUM:
Sum = num1 + num2
EndSUM
DISPLAY Sum
End
End TASK

1) ***Pseudocode to find given number is odd or even***

TASK: Find Odd or Even:
READ number
Compute MODULO:
Mod = number % 2;
End MODULO
IF Mod = 0:
PRINT “Number is Even”
ELSE:
PRINT “Number is Odd”
End TASK

1) ***Pseudocode to find factorial of given number*** TASK: Finding Factorial of a number
   READ number
   Initialize Fact to 0 and CurrentVal to number
   WHILE CurrentVal is not 1:
   IF CurretVal>= 1:
   Fact = Fact \* CurrentVal
   CurretVal = CurretVal - 1
   EndIF
   Else
   Print Fact
   End WHILE
   End
   End TASK


**1.5.2	FLOWCHARTS**

Flowchart is a ***diagrammatic representation*** of sequence of logical steps of a program. Flowcharts are a graphical means of representing an algorithm, as should be expected; they have advantages and disadvantages compared to pseudocode. One of their primary advantages is that they permit the structure of a program to be easily visualized - even if all the text were to be removed. The human brain is very good at picking out these patterns and keeping them "in the back of the mind" as a reference frame for viewing the code as it develops.

Most programmers also find it easier to sketch flowcharts on a piece of paper and to modify them by crossing out connection arrows and drawing new ones that they would working with pseudocode by hand. By the same token, most programmers do not like to develop flowcharts in an electronic format because the overhead of creating and modifying it is generally more than they want to deal with while pseudocode lends itself to such electronic development.

Furthermore, if the pseudocode is already in an electronic format that has been structured to lend itself to translation to the final language - such as the one recommended in the previous section - then doing so can be a very simply matter of copying the pseudocode to a new file, overlaying the necessary syntax associated with the language, and compiling the result. This can be a powerful advantage of pseudocode over flowcharts where the entire source code still has to be typed by hand unless you are fortunate to have a tool that can take a flowchart - typically developed using that same tool - and translating it to directly to code. Such tools do exist - and they tend to be rather expensive.

Now that we have looked as some of the pros and cons of flowcharts relative to pseudo code, let's delve into flowcharting itself. The idea behind a flowchart is that it links together a series of blocks each of which perform some specific task. Each of these tasks is represented by a block and has exactly one arrow leading to it and, more importantly, one arrow exiting from it. This is key to the concept of a "structured program".

The shape of the block may convey additional information about what is happening. For instance, ***a rectangular block*** is frequently used to indicate that ***a computation*** is occurring while **a slanted parallelogram** is used to indicate some type of **input or output operation**. The diversity of shapes that can be used and what they mean is staggering - for instance a different shape can be used to indicate output to a tape drive versus to a hard disk or to indicate output in text format verses binary format. By using such highly specialized symbols, much of what is happening can be conveyed by the symbols themselves. But the power of using these distinctions is generally only useful to people that work with flowcharts continuously, professionally, and who are describing very large and complex systems. At our level, it is far better to restrict ourselves to a minimum number of shapes and explicitly indicate any information that otherwise might have been implied by using a different shape.

![D:\flowchart.png](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.005.png)

***Figure 5: Symbols used in a Flowchart***

![](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.006.png)

***Figure 6: Common Flowchart Symbols***

***Circle - Entry/Exit Point:***

**The circle** indicates ***the entry and exit point*** for the program - or for the current segment of the program. The entry point has exactly one arrow leaving it and the exit point has exactly one arrow entering it. Execution of the program - or of that segment of the program - always starts at the entry point and finishes at the exit point.

***Rectangle – Task:***

**The rectangle** represents ***a task that is to be performed***. That task might be as simple as incrementing the value of a single variable or as complex as you can imagine. The key point is that it also has a single entry point and a single exit point.

***Parallelogram – Input / Output***

**The parallelogram** is used to indicate that some form in ***input/output operation*** is occurring. They must also obey the single entry single exit point rule which makes sense given that they are a task-block except with a slightly different shape for the symbol. We could easily eliminate this symbol and use the basic rectangle but the points at which I/O occur within our programs are extremely important and being able to easily and quickly identify them is valuable enough to warrant dealing with a special symbol.

Since a Task block can be arbitrarily complex, it can also contain I/O elements. Whether to use a rectangle or a parallelogram is therefore a judgment call. One way to handle this is to decide whether a task's primary purpose is to perform I/O. Again, that is a judgment call. Another option is to use a symbol that is rectangular on one side and slanted on the other indicating that it is performing both I/O and non-I/O tasks.

***Diamond - Decision Point***

**The diamond** represents ***a decision point*** within our program. A question is asked and depending on the resulting answer, different paths are taken. Therefore a diamond has a single entry point but more than one exit point. Usually, there are two exit points - one that is taken if the answer to the question is "true" and another that is taken if the answer to the question is "false". This is sufficient to represent any type of branching logic including both the typical selection statements and the typical repetition statements. However, most languages support some type of "switch" or "case" statement that allows the program to select one from among a potentially large set of possible paths. The basic two-exit-point diamond is fully capable of representing this construct, but it is generally cleaner and more useful to represent it using a as many exit points from the diamond as there are paths.

***Arrow – Inter block Flow***

**The arrows** simply ***show which symbol gets executed next***. The rule is that once an arrow leaves a symbol, it must lead directly to exactly one other symbol - arrows can never fork and diverge. They can, however, converge and join arrows coming from other blocks.

**Examples**

- ***Sum of two numbers flow chart***

![sum of two nos](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.007.png)


- ***Finding number is even or odd***

![odd or even](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.008.png)


- ***Program to Find a factorial of the given number***

![factorial](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.009.jpeg)



**1.6 	PROGRAMMING LANGUAGE NOTATION**

A programming language is a **formal language that specifies a set of instructions** that can be used to produce various kinds of output. Programming languages generally consist of instructions for a computer. Programming languages can be used to create programs that implement specific algorithms.

Eg : C, C++, COBAL, JAVA, Python ... etc

Programming language consists of syntax and semantics to process by the compiler or interpreter we must represent our logic with proper notations otherwise the program won’t work at all.

***Let’s take a python program to compute sum of two numbers,***

num1 = input('Enter first number: ')

num2 = input('Enter second number: ')

\# Add two numbers3

sum = int(num1) + int(num2)

\# Display the sum

print(sum)

***Let’s take a C program to compute sum of two numbers,***

#include<stdio.h>

int main(){

int num1, int num2, sum;

printf (Enter first number:”);

scanf(“%d”,&num1);

printf (Enter second number:”);

scanf(“%d”,&num2);

sum = num1 + num2;

printf(“%d”, sum)

return 0;

}

***Let’s take a Java program to compute sum of two numbers,***

class Main{

public static void main(String[] args){

int num1, num2, sum;

Scanner in = new Scanner(System.in);

System.out.println(“Enter first number:”);

num1 = in.nextInt();

System.out.println(“Enter second number:”);

num2 = in.nextInt();

sum = num1 + num2;

System.out.println(sum);

}

}

Above that we have 3 styles of the programming with 3 different languages but achieve the same logic.

These programs differ only by syntax and rules.

**Python**
●It is dynamic type no declaration of variable needed.
●Just do and display.
● It is based on Dynamic OOPS.

**C**
● It is structure oriented we need to declare a variable before we use it.
● Anything that represented as block of codes and do the work.
● It is procedure oriented structured language.

**JAVA**
● It is object oriented derived from C and C++
● Coding style is inherited from C and C++ for easy transformation.
● Everything is considered as objects and depends on dynamic memory allocations.

**1.7 ALGORITHMIC PROBLEM SOLVING:**

An algorithm is a defined set of step-by-step procedures that provides the correct answer to a particular problem. Algorithmic problem solving is solving problem that require the formulation of an algorithm for their solution. The formulation of algorithm is always been an important element of problem solving. We can consider algorithms to be procedural solutions to problems.

![C:\Users\Mohan\Desktop\APS.png](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.010.png)

***Figure 7: Algorithm design and analysis process***

**The fundamental steps are:** 

- Understanding the problem 
- Ascertaining the capabilities of computational device 
- Choose between exact and approximate problem solving 
- Decide on appropriate data structures 
- Algorithm design techniques 
- Methods for specifying the algorithm 
- Proving an algorithm’s correctness 
- Analyzing an algorithm 
- Coding an algorithm

**1. Understanding the problem :** 

The first thing we need to do before designing an algorithm is **to understand completely the problem given**. **Read the problem’s description carefully and ask questions if you have any doubts about the problem.** An input to an algorithm specifies an instance of the problem the algorithm solves.

It is very important to **specify exactly the range of instances** the algorithm needs to handle. **Correct algorithm** is not one that works most of the time, but **one that works correctly for all legitimate inputs.** Do not skimp on this first step of algorithmic problem-solving process; if we do, then we need to do unnecessary rework on it.

**2. Ascertain the capabilities of computational device :** 

Once you completely understand a problem, you need to ascertain the capabilities of the computational device the algorithm is intended for. If the instructions are executed one after another, one operation at a time. Algorithms designed to be executed on such machines are called ***sequential algorithm.*** If the instructions are executed concurrently, it is called ***parallel algorithm.***

**3. Choose between exact and approximate problem solving :** 

Next principal decision is to Choose between solving the problem exactly or solving the problem approximately.

Case 1: solving the problem exactly – an algorithm is called ***exact algorithm***

Case 2: solving the problem approximately – an algorithm is called ***approximation algorithm.***

First, some important problems cannot be solved exactly for most of their instances; example – extracting square roots solving nonlinear equations.

Second, available algorithm for solving a problem exactly can be unacceptably slow because of the problem’s intrinsic complexity

**4. Decide on appropriate data structures :**

Data structure plays a vital role in designing and analysis the algorithms.

Some of the algorithm design techniques also depend on the structuring or restructuring data specifying a problem’s instance.

**Algorithm+ Data structure=programs.**


**5. Algorithm Design Techniques:** 

An ***algorithm design technique*** (or “strategy” or “paradigm”) is ***a general approach to solving problems algorithmically*** that is applicable to a variety of problems from different areas of computing. Learning these techniques is of at most importance for the following reasons:

- First, they provide guidance for designing algorithms for new problems,  ex : problems for which there is no known satisfactory algorithm.
- Second, algorithms are the cornerstone of computer science. 

Algorithm design techniques make it possible to classify algorithms according to an underlying design idea.

**6. Methods of Specifying an Algorithm:** 

Three ways to specify an algorithm

1. Pseudocode 
1. Flowchart
1. Programming language

**6.1 Pseudocode :**

***Pseudocode*** is a mixture of a natural language and programming language-like*** constructs. It is usually more precise than natural language, and its usage often yields more concise algorithm descriptions.

**6.2 Flowchart:**

In the earlier days of computing, the dominant vehicle for specifying algorithms was a ***flowchart.***

***A Flow chart*** is a method of expressing an algorithm by a collection of connected geometric shapes containing descriptions of the algorithm’s steps.

**6.3 Programming language:**

A programming language is a formal language that specifies a set of instructions that can be used to produce various kinds of output. 

Programming languages generally consist of ***instructions for a computer***. Programming languages can be used to create programs that implement specific algorithms.

Eg : C, C++, COBAL, JAVA, Python ... Etc

**7. Proving an Algorithm’s correctness:** 

Once the algorithm has been specified, then its ***correctness*** must be proved. An algorithm must yield a required result for every legitimate input in a finite amount of time. For some algorithm, a proof of correctness is quite easy; for others, it can be quite complex.

A common technique for proving correctness is to ***use mathematical induction*** because an algorithm’s iterations provide a natural sequence of steps needed for such proofs. The notion of correctness for approximation algorithm is less straightforward than it is for exact algorithms.

**8. Analyzing an Algorithm:** 

Our algorithms need to possess several qualities. After correctness, the most important one is efficiency. There are two kind of algorithm efficiency: i) **Time efficiency**    ii) **Space efficiency**

**Time efficiency**: Indicates **how fast the algorithm runs**.

***Space efficiency***: indicates ***how much extra memory*** the algorithm needs.

Another desirable characteristic’s of an algorithm are ***simplicity and generality.*** If you are not satisfied with the algorithm’s ***efficiency, simplicity, or generality,*** you must return to the drawing board and redesign the algorithm.

**9. Coding an Algorithm:** 

Most algorithms are destined to be ultimately implemented as computer programs. The coding / implementation of an algorithm is done by a suitable programming language like C, C++, JAVA It is very essential to write an optimized code (efficient code) to reduce the burden of compiler.

As a rule a good algorithm is a result of repeated effort and rework. Even if you have been fortunate enough to get an algorithmic idea that seems perfect, you should still try to see whether it can be improved. An important issue of algorithmic problem solving is the question of whether or not every problem can be solved by an algorithm. Fortunately, a vast majority of problems in practical computing can be solved by an algorithm.

**1.8** **SIMPLE STRATEGIES FOR DEVELOPING ALGORITHMS**

An algorithm is a defined set of step-by-step procedures that provides the correct answer to a particular problem.

There are some simple strategies for developing algorithms: Iteration, Recursion

**1.8.1 ITERATION:**

A sequence that is executed repeatedly so long as a certain condition holds. A sequence of statements is executed until a specified condition is true is called ***iterations.*** 

- ` `for loop
- while loop

**for loop:**

The **for-loop** sets up a **control variable** that manages execution of the loop. Execution iterates over the items in a sequence (the value of each item is assigned to the control variable at the beginning of each pass through the loop).That sequence could, for example, be a list. 

In the following code sample, the variable ***word*** is used as a control variable. At the beginning of each iteration of the loop, it is assigned the next value from the list ***words*** from beginning to end.

**Syntax of  for loop:**

**FOR( start-value to end-value) DO**

**Statement**

**...**

**ENDFOR**

**Example 1: Psuedocode for print *n* natural numbers**

BEGIN

GET n

INITIALIZE i=1

FOR (i<=n) DO

PRINT i 

i=i+1

ENDFOR

END

**Example 2: for loop:**

\# This prints out the length of each word in a list of words

words = [‘my’, ‘big’, ‘meal’, ‘comes’, ‘mostly’, ‘bearing’, ‘doubtful’, ‘garnishes’]

for **word** in words: 

\# The following line prints the length of the word 

` `print(len(word))

` 	`# Prints: 2 3 4 5 6 7 8 9


**While loop:**

The while loop **executes a block of instructions repeatedly** for as long as some condition evaluates to true. The **value of the condition is only checked at the beginning of each iteration**. As soon as the condition evaluates to false, the loop ends and execution jumps immediately to the next line following the end of the while block.

**Syntax of  while loop:**

WHILE (condition) DO

Statement

...              

ENDWHILE

**While loop: example 1: Algorithm and pseudocode to find power of a number:**

Step 1: Get a base number
Step 2: Get a power
Step 3: Initialize result value with number and pow with power
Step 4: Start with pow as 1
Step 5: Multiply result and number then increase pow by one
Step 6: Repeat Step 5 Until pow reaches value of power
Step 7: Break the loop and display the result
Step 8: End

**In pseudocode:**

TASK: To Find Power of a number
READ number
READ Power
Initialize result with number and pow with Power
WHILE pow< Power:
result = result \* number
Increase pow by 1
End Loop
PRINT result
End


**While loop: example 2: pseudocode for Print *n* natural numbers:**

BEGIN

GET n

INITIALIZE i=1

WHILE(i<=n) DO

PRINT i 

i=i+1

ENDWHILE

END

**While loop: example 3:** 

#This program invites the user to guess a number (set in the# age variable). As long as they haven’t guessed correctly, the program keeps asking. 

**age = 25**

**guess = 0**

**while age != guess:** 
**
` `# Whereas a == b tests whether a and b are equal, a != b tests whether a and b are not equal 

\# The int() function turns the user’s input (which is text) into an integer. 

` 	`**guess = int(input(‘Guess how old I am> ‘))**

**print(‘You got it right!’)**

**1.8.2 RECURSION:**

**A function that calls itself** is known as ***recursion***. Recursion is a process by which a function calls itself repeatedly until some specified condition has been satisfied. A physical world example would be to **place two parallel mirrors facing each other.** Any object in between them would be reflected recursively.

A recursive algorithm is an algorithm which calls itself with "smaller (or simpler)" input values, and which obtains the result for the current input by applying simple operations to the returned value for the smaller (or simpler) input. More generally if a problem can be solved utilizing solutions to smaller versions of the same problem, and the smaller versions reduce to easily solvable cases, then one can use a recursive algorithm to solve that problem. For example, the elements of a recursively defined set, or the value of a recursively defined function can be obtained by a recursive algorithm.

If a set or a function is defined recursively, then a recursive algorithm to compute its members or values mirrors the definition. Initial steps of the recursive algorithm correspond to the basis clause of the recursive definition and they identify the basis elements. They are then followed by steps corresponding to the inductive clause, which reduce the computation for an element of one generation to that of elements of the immediately preceding generation.

In general, recursive computer programs require more memory and computation compared with iterative algorithms, but they are simpler and for many case a natural way of thinking about the problem.

**Example 1: To find power of a number:**

Step 1: Get a base number
Step 2: Get a power
Step 3: Send a number and power to routine
Step 4: In routine Compare power with 1
`      `Step 5: If it is equal to 1 then return number
`      `Step 6: Else Compute the same routine (Step 4 and 5) with a same number and reduced power by 1
Step 7: display the result
Step 8: End

**In pseudocode:**

TASK: To Find Power of a number
`         `READ number
`         `READ Power
`         `result = FIND\_POWER number and power
`         `FIND\_POWER number and power:
`                 `IF power = 1:
`                       `RETURN number
`                 `ELSE
`                       `result = FIND\_POWER number and power -1
`          `RETURN result
`          `End FIND\_POWER
`          `PRINT result
`          `End
End TASK

An algorithm starts from an initial state with some input. The instructions/statements describe the processing that must be done on the input to produce the final output (the final state). Note that an instruction is a single operation which when executed converts one state to other. In the course of processing, data is read from an input device, stored in computer’s memory for further processing, and then the result of the processing is written to an output device. The data is stored in the computer’s memory in the form of variables or constants. The state of an algorithm is defined as its condition regarding current values or contents of the stored data. An algorithm is a list of precise steps and the order of steps determines the functioning of the algorithm. The flow of control (or the control flow) of an algorithm can be specified as top-down or bottom-up approach. Thus, the flow of control specifies the order in which individual instructions of an algorithm are executed.

**Example 2: Algorithm for factorial of n numbers using recursion:**

**Main function:** 

Step1: Start 

Step2: Get n 

Step3: call factorial (n) 

Step4: print fact 

Step5: Stop 

` `**Sub function *factorial (n)*:** 

Step1: if(n==1) then fact=1 return fact 

Step2: else fact=n\*factorial (n-1) and return fact

![](Aspose.Words.8b6809a2-28ff-4aff-9ca1-240492abaa93.011.jpeg)

***Figure 8: Flowchart for factorial of* n *numbers using recursion***


**Pseudo code for factorial using recursion:**

**Main function:**

BEGIN

GET n

CALL factorial (n)

PRINT fact

END
**


**Sub function factorial (n):**

IF(n==1) THEN

fact=1

RETURN fact

ELSE

`          	`RETURN fact=n\*factorial(n-1)

**Advantages of Recursion:**

- Recursive functions **make the code look clean** and **elegant**.
- **A complex task can be broken down into simpler sub-problems** using recursion.
- **Sequence generation is easier** with recursion than using some nested iteration.

**Disadvantages of Recursion:**

- Sometimes the **logic behind recursion is hard to follow** through.
- Recursive calls are expensive (inefficient) as they **take up a lot of memory and time.**
- Recursive functions are **hard to debug.**




